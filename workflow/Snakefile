include: "rules/globals.smk"  # no rules only globals and asserts
include: "rules/blastp.smk"
include: "rules/interproscan.smk"


rule all:
    input:
        f"{RESULTS}/pairs.tsv",
        f"{RESULTS}/neighborhoods.tsv",
        f"{RESULTS}/mappings_wide.tsv",
        f"{RESULTS}/mappings_raw_wide.tsv",


rule download_genome:
    output:
        multiext(f"{RESULTS_GENOMES}/{{genome}}/{{genome}}", ".gff", ".faa"),
    params:
        include="protein gff3",
    retries: 3
    cache: "omit-software"
    shell:
        """
        workflow/scripts/download_genome.py --include {params.include} --out-dir {RESULTS_GENOMES}/{wildcards.genome} -- {wildcards.genome}
        """


rule cds:
    input:
        gff=rules.download_genome.output[0],
    output:
        cds=f"{RESULTS_GENOMES}/{{genome}}/{{genome}}_cds.tsv",
    shell:
        """
        workflow/scripts/reduce_gff2cds.R {input} >| {output}
        """


rule pids:
    input:
        tsv=rules.bind_blasts.output,
        faa=rules.all_proteins.output,
    output:
        f"{RESULTS}/{BLASTS_PID}",
    shell:
        """
        sed '1d' {input.tsv} | perl -ape '$_ = $F[3] . "\\n"' | sort | uniq >| {output}

        N_FAA=`grep -c '^>' {input.faa}`
        N_PID=`grep -c '^'  {input.tsv}` # wc -l clutters the output, so equality (==) fails

        # Sanity check, N == M
        # N unique faas
        # M unique pids
        # if [[ "$N_FAA" -ne "$N_PID" ]]; then printf "Fatal Error:\\nN unique fasta entries differ from\\nM unique protein ids.\\n" && exit 1; fi
        """


rule hits:
    input:
        cds=rules.cds.output.cds,
        pids=rules.pids.output,
    output:
        f"{RESULTS_GENOMES}/{{genome}}/{{genome}}_hits.tsv",
    shell:
        """
        workflow/scripts/cds2hits.R {input.pids} {input.cds} >| {output}
        """


rule bind_hits:
    input:
        ALL_HITS,
    output:
        f"{RESULTS}/hits.tsv",
    threads: workflow.cores
    shell:
        """
        workflow/scripts/bind_tabs.R {threads} {input} >| {output}
        """


rule mappings:
    input:
        iscan=rules.interproscan_tsv.output,
        blasts=rules.bind_blasts.output,
    output:
        f"{RESULTS}/mappings_raw.tsv",
    params:
        config=workflow.configfiles[0],
    shell:
        """
        workflow/scripts/mappings.R {params.config} {input.iscan} {input.blasts} >| {output}
        """


rule filter_mappings:
    input:
        raw=rules.mappings.output,
    output:
        filtered=f"{RESULTS}/mappings.tsv",
    params:
        config=workflow.configfiles[0],
    shell:
        """
        workflow/scripts/filter_mappings.R {params} {input} >| {output}
        """


mappings = (Path(rules.mappings.output[0]), Path(rules.filter_mappings.output[0]))
for maps in mappings:

    rule:
        name:
            f"{maps.stem}_wide"
        input:
            f"{maps}",
        output:
            f"{RESULTS}/{maps.stem}_wide.tsv",
        shell:
            "workflow/scripts/maps2wide.R {input} >| {output}"


rule pairs:
    input:
        hits=rules.bind_hits.output,
        maps=rules.filter_mappings.output,
    output:
        f"{RESULTS}/pairs.tsv",
    params:
        config=workflow.configfiles[0],
    shell:
        """
        workflow/scripts/pairs.R {params.config} {input.hits} {input.maps} {output}
        """


rule neighborhoods:
    input:
        mappings=rules.filter_mappings.output,
        cds=f"{RESULTS_GENOMES}/{{genome}}/{{genome}}_cds.tsv",
    output:
        f"{RESULTS_GENOMES}/{{genome}}/{{genome}}_neighborhoods.tsv",
    params:
        N=N,
    shell:
        """
        workflow/scripts/find_neighbors.R {input.mappings} {params.N} {input.cds} >| {output}
        """


rule bind_neighborhoods:
    input:
        ALL_HOODS,
    output:
        f"{RESULTS}/neighborhoods.tsv",
    threads: workflow.cores
    shell:
        """
        workflow/scripts/bind_tabs.R {threads} {input} >| {output}
        """
