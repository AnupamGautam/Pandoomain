include: "rules/globals.smk"  # no rules only globals, asserts, and utils
include: "rules/download.smk"


rule all:
    input:
        f"{RESULTS}/all.faa",


#      f"{RESULTS}/.splitted.sentinel",


rule hmmer_input:
    input:
        ALL_FAAS,
    output:
        f"{RESULTS}/.input_faas.txt",
    run:
        with open(f"{output}", "w") as fh:
            for faa in ALL_FAAS:
                fh.write(f"{faa}\n")


# Is an error not having a hit!
rule hmmer:
    input:
        faas=rules.hmmer_input.output,
    output:
        tsv=ensure(f"{RESULTS}/hmmer.tsv", non_empty=True),
    params:
        queries=f"{IN_QUERIES}",
    shell:
        r"""
        workflow/scripts/hmmer.py {params} {input} {output}
        """


rule get_neighbors:
    input:
        hmmer=rules.hmmer.output,
    output:
        neighbors=ensure(f"{RESULTS}/neighbors.tsv", non_empty=True),
    threads: workflow.cores
    params:
        N=8,
        gdir=f"{RESULTS}/genomes",
    shell:
        """
        workflow/scripts/neighbors.R {threads} {params} {input} >| {output}
        """


rule all_faas_raw:
    input:
        neighbors=rules.get_neighbors.output,
    output:
        faa=f"{RESULTS}/.all.unsorted.faa",
    params:
        db=f"{RESULTS_GENOMES}",
    threads: workflow.cores
    shell:
        r"""
        workflow/scripts/harvest.R {params} {threads} {input} >| {output}
        """


rule all_faas:
    input:
        neighbors=rules.all_faas_raw.output,
    output:
        faa=f"{RESULTS}/all.faa",
    shell:
        r"""
       fasta_sort < {input} 2> /dev/null | fasta_pretty -w=80 >| {output}

       # assert that unsorted and sorted have the same line length
       fun () {{
                perl -ne 'print(length($_)."\n");' < "$1" | sort -n | uniq -c | sort -nr | head
       }}

       X="$(fun {input})"
       Y="$(fun {output})"
       test "$X" '==' "$Y"
       """


# rule hmmer:
#     input:
#         faas=rules.hmmer_input.output,
#     output:
#         tsv=f"{RESULTS}/hmmer.tsv",
#     params:
#         queries=f"{IN_QUERIES}",
#     shell:
#         r"""
#         workflow/scripts/hmmer.py {params} {input} {output}
#         """
#     run:
#         with open(f"{output}", "w") as fh:
#             for faa in ALL_FAAS:
#                 fh.write(f"{faa}\n")


rule interproscan:
    input:
        faa=rules.all_faas.output,
    output:
        multiext(f"{RESULTS}/.iscan", ".tsv", ".xml"),
    params:
        tmp="/tmp",
        batch=64000,
    threads: workflow.cores
    cache: True
    shell:
        """
        workflow/scripts/iscan.py {threads} {params} {input} {output}
        """


rule add_header:
    input:
        tsv=rules.interproscan.output[0],
    output:
        tsv=f"{RESULTS}/iscan.tsv",
    params:
        header=ISCAN_HEADER,
    shell:
        """
        # Annotate headers
        cat - {input.tsv} <<< '{params}' >| {output}
        """


rule get_archs:
    input:
        tsv=rules.add_header.output,
    output:
        archs=f"{RESULTS}/archs.tsv",
        pidrow=f"{RESULTS}/archs_pidrow.tsv",
        code=f"{RESULTS}/archs_code.tsv",
    shell:
        """
        workflow/scripts/archs.R {input} {output}
        """


rule get_absence_presence:
    input:
        taxa=rules.join_genomes_taxallnomy.output,
        proteins=rules.hmmer.output,
        domains=rules.get_archs.output.archs,
    output:
        TGPD=f"{RESULTS}/TGPD.tsv",
        absence_presence=f"{RESULTS}/absence_presence.tsv",
    shell:
        """
        workflow/scripts/absence_presence.R {input} {output}
        """
